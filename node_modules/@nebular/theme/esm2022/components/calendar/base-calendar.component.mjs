/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { Component, EventEmitter, HostBinding, Input, Output } from '@angular/core';
import { NbCalendarSize, NbCalendarViewMode, } from '../calendar-kit/model';
import { convertToBoolProperty } from '../helpers';
import * as i0 from "@angular/core";
import * as i1 from "../calendar-kit/services/date.service";
import * as i2 from "../calendar-kit/services/calendar-year-model.service";
import * as i3 from "../calendar-kit/components/calendar-navigation/calendar-view-mode.component";
import * as i4 from "../calendar-kit/components/calendar-navigation/calendar-pageable-navigation.component";
import * as i5 from "../calendar-kit/components/calendar-year-picker/calendar-year-picker.component";
import * as i6 from "../calendar-kit/components/calendar-month-picker/calendar-month-picker.component";
import * as i7 from "../calendar-kit/components/calendar-day-picker/calendar-day-picker.component";
import * as i8 from "@angular/common";
import * as i9 from "../card/card.component";
/**
 * The basis for calendar and range calendar components.
 * Encapsulates common behavior - store calendar state and perform navigation
 * between pickers.
 * */
export class NbBaseCalendarComponent {
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    constructor(dateService, yearModelService) {
        this.dateService = dateService;
        this.yearModelService = yearModelService;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines active view for calendar.
         * */
        this.activeViewMode = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines whether we should show calendar navigation or not.
         * */
        this.showNavigation = true;
        this._showWeekNumber = false;
        /**
         * Emits date when selected.
         * */
        this.dateChange = new EventEmitter();
        this.ViewMode = NbCalendarViewMode;
    }
    ngOnInit() {
        if (!this.visibleDate) {
            this.visibleDate = this.dateService.today();
        }
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    setViewMode(viewMode) {
        this.activeViewMode = viewMode;
    }
    setVisibleDate(visibleDate) {
        this.visibleDate = visibleDate;
    }
    prevMonth() {
        this.changeVisibleMonth(-1);
    }
    nextMonth() {
        this.changeVisibleMonth(1);
    }
    prevYear() {
        this.changeVisibleYear(-1);
    }
    nextYear() {
        this.changeVisibleYear(1);
    }
    prevYears() {
        this.changeVisibleYears(-1);
    }
    nextYears() {
        this.changeVisibleYears(1);
    }
    navigatePrev() {
        switch (this.activeViewMode) {
            case NbCalendarViewMode.DATE:
                return this.prevMonth();
            case NbCalendarViewMode.MONTH:
                return this.prevYear();
            case NbCalendarViewMode.YEAR:
                return this.prevYears();
        }
    }
    navigateNext() {
        switch (this.activeViewMode) {
            case NbCalendarViewMode.DATE:
                return this.nextMonth();
            case NbCalendarViewMode.MONTH:
                return this.nextYear();
            case NbCalendarViewMode.YEAR:
                return this.nextYears();
        }
    }
    onChangeViewMode() {
        if (this.activeViewMode === NbCalendarViewMode.DATE) {
            return this.setViewMode(NbCalendarViewMode.YEAR);
        }
        this.setViewMode(NbCalendarViewMode.DATE);
    }
    changeVisibleMonth(direction) {
        this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
    }
    changeVisibleYear(direction) {
        this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
    }
    changeVisibleYears(direction) {
        this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NbBaseCalendarComponent, deps: [{ token: i1.NbDateService }, { token: i2.NbCalendarYearModelService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NbBaseCalendarComponent, selector: "nb-base-calendar", inputs: { boundingMonth: "boundingMonth", activeViewMode: ["startView", "activeViewMode"], min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", size: "size", visibleDate: "visibleDate", showNavigation: "showNavigation", date: "date", showWeekNumber: "showWeekNumber", weekNumberSymbol: "weekNumberSymbol", firstDayOfWeek: "firstDayOfWeek" }, outputs: { dateChange: "dateChange" }, host: { properties: { "class.has-navigation": "this.showNavigation", "class.has-week-number": "this.showWeekNumber", "class.size-large": "this.large" } }, ngImport: i0, template: "<nb-card>\n  <nb-card-header *ngIf=\"showNavigation\" class=\"calendar-navigation\">\n    <nb-calendar-view-mode [date]=\"visibleDate\"\n                           [viewMode]=\"activeViewMode\"\n                           (changeMode)=\"onChangeViewMode()\">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)=\"navigatePrev()\" (next)=\"navigateNext()\">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]=\"activeViewMode\">\n\n    <nb-calendar-day-picker *ngSwitchCase=\"ViewMode.DATE\"\n                            [boundingMonths]=\"boundingMonth\"\n                            [cellComponent]=\"dayCellComponent\"\n                            [min]=\"min\"\n                            [max]=\"max\"\n                            [filter]=\"filter\"\n                            [visibleDate]=\"visibleDate\"\n                            [size]=\"size\"\n                            [date]=\"date\"\n                            [showWeekNumber]=\"showWeekNumber\"\n                            [firstDayOfWeek]=\"firstDayOfWeek\"\n                            (dateChange)=\"dateChange.emit($any($event))\"\n                            [weekNumberSymbol]=\"weekNumberSymbol\">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase=\"ViewMode.YEAR\"\n                             [cellComponent]=\"yearCellComponent\"\n                             [date]=\"$any(date)\"\n                             [min]=\"min\"\n                             [max]=\"max\"\n                             [filter]=\"filter\"\n                             [size]=\"size\"\n                             [year]=\"visibleDate\"\n                             (yearChange)=\"setVisibleDate($event); setViewMode(ViewMode.MONTH)\">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase=\"ViewMode.MONTH\"\n                              [cellComponent]=\"monthCellComponent\"\n                              [min]=\"min\"\n                              [max]=\"max\"\n                              [filter]=\"filter\"\n                              [size]=\"size\"\n                              [month]=\"visibleDate\"\n                              [date]=\"$any(date)\"\n                              (monthChange)=\"setVisibleDate($event); setViewMode(ViewMode.DATE)\">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n", dependencies: [{ kind: "component", type: i3.NbCalendarViewModeComponent, selector: "nb-calendar-view-mode", inputs: ["date", "viewMode"], outputs: ["changeMode"] }, { kind: "component", type: i4.NbCalendarPageableNavigationComponent, selector: "nb-calendar-pageable-navigation", outputs: ["next", "prev"] }, { kind: "component", type: i5.NbCalendarYearPickerComponent, selector: "nb-calendar-year-picker", inputs: ["date", "min", "max", "filter", "cellComponent", "size", "year"], outputs: ["yearChange"] }, { kind: "component", type: i6.NbCalendarMonthPickerComponent, selector: "nb-calendar-month-picker", inputs: ["min", "max", "filter", "size", "month", "date", "cellComponent"], outputs: ["monthChange"] }, { kind: "component", type: i7.NbCalendarDayPickerComponent, selector: "nb-calendar-day-picker", inputs: ["visibleDate", "boundingMonths", "min", "max", "filter", "cellComponent", "size", "date", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"], outputs: ["dateChange"] }, { kind: "directive", type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i8.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i8.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "component", type: i9.NbCardComponent, selector: "nb-card", inputs: ["size", "status", "accent"] }, { kind: "component", type: i9.NbCardBodyComponent, selector: "nb-card-body" }, { kind: "component", type: i9.NbCardHeaderComponent, selector: "nb-card-header" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NbBaseCalendarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nb-base-calendar', template: "<nb-card>\n  <nb-card-header *ngIf=\"showNavigation\" class=\"calendar-navigation\">\n    <nb-calendar-view-mode [date]=\"visibleDate\"\n                           [viewMode]=\"activeViewMode\"\n                           (changeMode)=\"onChangeViewMode()\">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)=\"navigatePrev()\" (next)=\"navigateNext()\">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]=\"activeViewMode\">\n\n    <nb-calendar-day-picker *ngSwitchCase=\"ViewMode.DATE\"\n                            [boundingMonths]=\"boundingMonth\"\n                            [cellComponent]=\"dayCellComponent\"\n                            [min]=\"min\"\n                            [max]=\"max\"\n                            [filter]=\"filter\"\n                            [visibleDate]=\"visibleDate\"\n                            [size]=\"size\"\n                            [date]=\"date\"\n                            [showWeekNumber]=\"showWeekNumber\"\n                            [firstDayOfWeek]=\"firstDayOfWeek\"\n                            (dateChange)=\"dateChange.emit($any($event))\"\n                            [weekNumberSymbol]=\"weekNumberSymbol\">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase=\"ViewMode.YEAR\"\n                             [cellComponent]=\"yearCellComponent\"\n                             [date]=\"$any(date)\"\n                             [min]=\"min\"\n                             [max]=\"max\"\n                             [filter]=\"filter\"\n                             [size]=\"size\"\n                             [year]=\"visibleDate\"\n                             (yearChange)=\"setVisibleDate($event); setViewMode(ViewMode.MONTH)\">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase=\"ViewMode.MONTH\"\n                              [cellComponent]=\"monthCellComponent\"\n                              [min]=\"min\"\n                              [max]=\"max\"\n                              [filter]=\"filter\"\n                              [size]=\"size\"\n                              [month]=\"visibleDate\"\n                              [date]=\"$any(date)\"\n                              (monthChange)=\"setVisibleDate($event); setViewMode(ViewMode.DATE)\">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n" }]
        }], ctorParameters: function () { return [{ type: i1.NbDateService }, { type: i2.NbCalendarYearModelService }]; }, propDecorators: { boundingMonth: [{
                type: Input
            }], activeViewMode: [{
                type: Input,
                args: ['startView']
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], filter: [{
                type: Input
            }], dayCellComponent: [{
                type: Input
            }], monthCellComponent: [{
                type: Input
            }], yearCellComponent: [{
                type: Input
            }], size: [{
                type: Input
            }], visibleDate: [{
                type: Input
            }], showNavigation: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.has-navigation']
            }], date: [{
                type: Input
            }], showWeekNumber: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.has-week-number']
            }], weekNumberSymbol: [{
                type: Input
            }], firstDayOfWeek: [{
                type: Input
            }], dateChange: [{
                type: Output
            }], large: [{
                type: HostBinding,
                args: ['class.size-large']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jYWxlbmRhci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL3RoZW1lL2NvbXBvbmVudHMvY2FsZW5kYXIvYmFzZS1jYWxlbmRhci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL3RoZW1lL2NvbXBvbmVudHMvY2FsZW5kYXIvYmFzZS1jYWxlbmRhci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFHbEcsT0FBTyxFQUVMLGNBQWMsRUFDZCxrQkFBa0IsR0FHbkIsTUFBTSx1QkFBdUIsQ0FBQztBQUUvQixPQUFPLEVBQUUscUJBQXFCLEVBQWtCLE1BQU0sWUFBWSxDQUFDOzs7Ozs7Ozs7OztBQUVuRTs7OztLQUlLO0FBS0wsTUFBTSxPQUFPLHVCQUF1QjtJQWlFbEM7OztTQUdLO0lBQ0wsSUFFSSxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5QixDQUFDO0lBQ0QsSUFBSSxjQUFjLENBQUMsS0FBYztRQUMvQixJQUFJLENBQUMsZUFBZSxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFvQkQsWUFDWSxXQUE2QixFQUM3QixnQkFBK0M7UUFEL0MsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO1FBQzdCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBK0I7UUFoRzNEOzs7YUFHSztRQUNJLGtCQUFhLEdBQVksSUFBSSxDQUFDO1FBRXZDOzthQUVLO1FBQ2UsbUJBQWMsR0FBdUIsa0JBQWtCLENBQUMsSUFBSSxDQUFDO1FBaUNqRjs7O2FBR0s7UUFDSSxTQUFJLEdBQW1CLGNBQWMsQ0FBQyxNQUFNLENBQUM7UUFLdEQ7O2FBRUs7UUFHTCxtQkFBYyxHQUFZLElBQUksQ0FBQztRQW1CckIsb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFjbEM7O2FBRUs7UUFDSyxlQUFVLEdBQW9CLElBQUksWUFBWSxFQUFFLENBQUM7UUFrQjNELGFBQVEsR0FBRyxrQkFBa0IsQ0FBQztJQWIzQixDQUFDO0lBRUosUUFBUTtRQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUM3QztJQUNILENBQUM7SUFFRCxJQUNJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxDQUFDLEtBQUssQ0FBQztJQUM1QyxDQUFDO0lBSUQsV0FBVyxDQUFDLFFBQTRCO1FBQ3RDLElBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRCxjQUFjLENBQUMsV0FBYztRQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRUQsU0FBUztRQUNQLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxTQUFTO1FBQ1AsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELFNBQVM7UUFDUCxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsU0FBUztRQUNQLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsWUFBWTtRQUNWLFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUMzQixLQUFLLGtCQUFrQixDQUFDLElBQUk7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQzFCLEtBQUssa0JBQWtCLENBQUMsS0FBSztnQkFDM0IsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDekIsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJO2dCQUMxQixPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFRCxZQUFZO1FBQ1YsUUFBUSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQzNCLEtBQUssa0JBQWtCLENBQUMsSUFBSTtnQkFDMUIsT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDMUIsS0FBSyxrQkFBa0IsQ0FBQyxLQUFLO2dCQUMzQixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN6QixLQUFLLGtCQUFrQixDQUFDLElBQUk7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQzNCO0lBQ0gsQ0FBQztJQUVELGdCQUFnQjtRQUNkLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUU7WUFDbkQsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU8sa0JBQWtCLENBQUMsU0FBaUI7UUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFTyxpQkFBaUIsQ0FBQyxTQUFpQjtRQUN6QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVPLGtCQUFrQixDQUFDLFNBQWlCO1FBQzFDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7SUFDcEgsQ0FBQzsrR0ExTFUsdUJBQXVCO21HQUF2Qix1QkFBdUIsNnJCQzVCcEMsazRFQXFEQTs7NEZEekJhLHVCQUF1QjtrQkFKbkMsU0FBUzsrQkFDRSxrQkFBa0I7NklBU25CLGFBQWE7c0JBQXJCLEtBQUs7Z0JBS2MsY0FBYztzQkFBakMsS0FBSzt1QkFBQyxXQUFXO2dCQU1ULEdBQUc7c0JBQVgsS0FBSztnQkFLRyxHQUFHO3NCQUFYLEtBQUs7Z0JBS0csTUFBTTtzQkFBZCxLQUFLO2dCQUtHLGdCQUFnQjtzQkFBeEIsS0FBSztnQkFLRyxrQkFBa0I7c0JBQTFCLEtBQUs7Z0JBS0csaUJBQWlCO3NCQUF6QixLQUFLO2dCQU1HLElBQUk7c0JBQVosS0FBSztnQkFHRyxXQUFXO3NCQUFuQixLQUFLO2dCQU9OLGNBQWM7c0JBRmIsS0FBSzs7c0JBQ0wsV0FBVzt1QkFBQyxzQkFBc0I7Z0JBTTFCLElBQUk7c0JBQVosS0FBSztnQkFRRixjQUFjO3NCQUZqQixLQUFLOztzQkFDTCxXQUFXO3VCQUFDLHVCQUF1QjtnQkFhM0IsZ0JBQWdCO3NCQUF4QixLQUFLO2dCQU1HLGNBQWM7c0JBQXRCLEtBQUs7Z0JBS0ksVUFBVTtzQkFBbkIsTUFBTTtnQkFjSCxLQUFLO3NCQURSLFdBQVc7dUJBQUMsa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZSB9IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9zZXJ2aWNlcy9jYWxlbmRhci15ZWFyLW1vZGVsLnNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgTmJDYWxlbmRhckNlbGwsXG4gIE5iQ2FsZW5kYXJTaXplLFxuICBOYkNhbGVuZGFyVmlld01vZGUsXG4gIE5iQ2FsZW5kYXJTaXplVmFsdWVzLFxuICBOYkNhbGVuZGFyVmlld01vZGVWYWx1ZXMsXG59IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9tb2RlbCc7XG5pbXBvcnQgeyBOYkRhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY2FsZW5kYXIta2l0L3NlcnZpY2VzL2RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBjb252ZXJ0VG9Cb29sUHJvcGVydHksIE5iQm9vbGVhbklucHV0IH0gZnJvbSAnLi4vaGVscGVycyc7XG5cbi8qKlxuICogVGhlIGJhc2lzIGZvciBjYWxlbmRhciBhbmQgcmFuZ2UgY2FsZW5kYXIgY29tcG9uZW50cy5cbiAqIEVuY2Fwc3VsYXRlcyBjb21tb24gYmVoYXZpb3IgLSBzdG9yZSBjYWxlbmRhciBzdGF0ZSBhbmQgcGVyZm9ybSBuYXZpZ2F0aW9uXG4gKiBiZXR3ZWVuIHBpY2tlcnMuXG4gKiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmItYmFzZS1jYWxlbmRhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9iYXNlLWNhbGVuZGFyLmNvbXBvbmVudC5odG1sJyxcbn0pXG5leHBvcnQgY2xhc3MgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQ8RCwgVD4gaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAqICovXG4gIEBJbnB1dCgpIGJvdW5kaW5nTW9udGg6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGFjdGl2ZSB2aWV3IGZvciBjYWxlbmRhci5cbiAgICogKi9cbiAgQElucHV0KCdzdGFydFZpZXcnKSBhY3RpdmVWaWV3TW9kZTogTmJDYWxlbmRhclZpZXdNb2RlID0gTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9hY3RpdmVWaWV3TW9kZTogTmJDYWxlbmRhclZpZXdNb2RlVmFsdWVzO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGF2YWlsYWJsZSBkYXRlIGZvciBzZWxlY3Rpb24uXG4gICAqICovXG4gIEBJbnB1dCgpIG1pbjogRDtcblxuICAvKipcbiAgICogTWF4aW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgKiAqL1xuICBASW5wdXQoKSBtYXg6IEQ7XG5cbiAgLyoqXG4gICAqIFByZWRpY2F0ZSB0aGF0IGRlY2lkZXMgd2hpY2ggY2VsbHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICogKi9cbiAgQElucHV0KCkgZmlsdGVyOiAoRCkgPT4gYm9vbGVhbjtcblxuICAvKipcbiAgICogQ3VzdG9tIGRheSBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAqICovXG4gIEBJbnB1dCgpIGRheUNlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuXG4gIC8qKlxuICAgKiBDdXN0b20gbW9udGggY2VsbCBjb21wb25lbnQuIEhhdmUgdG8gaW1wbGVtZW50IGBOYkNhbGVuZGFyQ2VsbGAgaW50ZXJmYWNlLlxuICAgKiAqL1xuICBASW5wdXQoKSBtb250aENlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuXG4gIC8qKlxuICAgKiBDdXN0b20geWVhciBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAqICovXG4gIEBJbnB1dCgpIHllYXJDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcblxuICAvKipcbiAgICogU2l6ZSBvZiB0aGUgY2FsZW5kYXIgYW5kIGVudGlyZSBjb21wb25lbnRzLlxuICAgKiBDYW4gYmUgJ21lZGl1bScgd2hpY2ggaXMgZGVmYXVsdCBvciAnbGFyZ2UnLlxuICAgKiAqL1xuICBASW5wdXQoKSBzaXplOiBOYkNhbGVuZGFyU2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3NpemU6IE5iQ2FsZW5kYXJTaXplVmFsdWVzO1xuXG4gIEBJbnB1dCgpIHZpc2libGVEYXRlOiBEO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIHNob3cgY2FsZW5kYXIgbmF2aWdhdGlvbiBvciBub3QuXG4gICAqICovXG4gIEBJbnB1dCgpXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaGFzLW5hdmlnYXRpb24nKVxuICBzaG93TmF2aWdhdGlvbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFZhbHVlIHdoaWNoIHdpbGwgYmUgcmVuZGVyZWQgYXMgc2VsZWN0ZWQuXG4gICAqICovXG4gIEBJbnB1dCgpIGRhdGU6IFQ7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICogRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogKi9cbiAgQElucHV0KClcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5oYXMtd2Vlay1udW1iZXInKVxuICBnZXQgc2hvd1dlZWtOdW1iZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3dXZWVrTnVtYmVyO1xuICB9XG4gIHNldCBzaG93V2Vla051bWJlcih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcm90ZWN0ZWQgX3Nob3dXZWVrTnVtYmVyID0gZmFsc2U7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zaG93V2Vla051bWJlcjogTmJCb29sZWFuSW5wdXQ7XG5cbiAgLyoqXG4gICAqIFNldHMgc3ltYm9sIHVzZWQgYXMgYSBoZWFkZXIgZm9yIHdlZWsgbnVtYmVycyBjb2x1bW5cbiAgICogKi9cbiAgQElucHV0KCkgd2Vla051bWJlclN5bWJvbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTZXRzIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgaXQgY2FuIGJlIDEgaWYgd2VlayBzdGFydHMgZnJvbSBtb25kYXkgYW5kIDAgaWYgZnJvbSBzdW5kYXkgYW5kIHNvIG9uLlxuICAgKiBgdW5kZWZpbmVkYCBtZWFucyB0aGF0IGRlZmF1bHQgbG9jYWxlIHNldHRpbmcgd2lsbCBiZSB1c2VkLlxuICAgKiAqL1xuICBASW5wdXQoKSBmaXJzdERheU9mV2VlazogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBkYXRlIHdoZW4gc2VsZWN0ZWQuXG4gICAqICovXG4gIEBPdXRwdXQoKSBkYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8VD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGRhdGVTZXJ2aWNlOiBOYkRhdGVTZXJ2aWNlPEQ+LFxuICAgIHByb3RlY3RlZCB5ZWFyTW9kZWxTZXJ2aWNlOiBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZTxEPixcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlRGF0ZSkge1xuICAgICAgdGhpcy52aXNpYmxlRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKTtcbiAgICB9XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbGFyZ2UnKVxuICBnZXQgbGFyZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gTmJDYWxlbmRhclNpemUuTEFSR0U7XG4gIH1cblxuICBWaWV3TW9kZSA9IE5iQ2FsZW5kYXJWaWV3TW9kZTtcblxuICBzZXRWaWV3TW9kZSh2aWV3TW9kZTogTmJDYWxlbmRhclZpZXdNb2RlKSB7XG4gICAgdGhpcy5hY3RpdmVWaWV3TW9kZSA9IHZpZXdNb2RlO1xuICB9XG5cbiAgc2V0VmlzaWJsZURhdGUodmlzaWJsZURhdGU6IEQpIHtcbiAgICB0aGlzLnZpc2libGVEYXRlID0gdmlzaWJsZURhdGU7XG4gIH1cblxuICBwcmV2TW9udGgoKSB7XG4gICAgdGhpcy5jaGFuZ2VWaXNpYmxlTW9udGgoLTEpO1xuICB9XG5cbiAgbmV4dE1vbnRoKCkge1xuICAgIHRoaXMuY2hhbmdlVmlzaWJsZU1vbnRoKDEpO1xuICB9XG5cbiAgcHJldlllYXIoKSB7XG4gICAgdGhpcy5jaGFuZ2VWaXNpYmxlWWVhcigtMSk7XG4gIH1cblxuICBuZXh0WWVhcigpIHtcbiAgICB0aGlzLmNoYW5nZVZpc2libGVZZWFyKDEpO1xuICB9XG5cbiAgcHJldlllYXJzKCkge1xuICAgIHRoaXMuY2hhbmdlVmlzaWJsZVllYXJzKC0xKTtcbiAgfVxuXG4gIG5leHRZZWFycygpIHtcbiAgICB0aGlzLmNoYW5nZVZpc2libGVZZWFycygxKTtcbiAgfVxuXG4gIG5hdmlnYXRlUHJldigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWN0aXZlVmlld01vZGUpIHtcbiAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU6XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNb250aCgpO1xuICAgICAgY2FzZSBOYkNhbGVuZGFyVmlld01vZGUuTU9OVEg6XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZZZWFyKCk7XG4gICAgICBjYXNlIE5iQ2FsZW5kYXJWaWV3TW9kZS5ZRUFSOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2WWVhcnMoKTtcbiAgICB9XG4gIH1cblxuICBuYXZpZ2F0ZU5leHQoKSB7XG4gICAgc3dpdGNoICh0aGlzLmFjdGl2ZVZpZXdNb2RlKSB7XG4gICAgICBjYXNlIE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFOlxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0TW9udGgoKTtcbiAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLk1PTlRIOlxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0WWVhcigpO1xuICAgICAgY2FzZSBOYkNhbGVuZGFyVmlld01vZGUuWUVBUjpcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFllYXJzKCk7XG4gICAgfVxuICB9XG5cbiAgb25DaGFuZ2VWaWV3TW9kZSgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVWaWV3TW9kZSA9PT0gTmJDYWxlbmRhclZpZXdNb2RlLkRBVEUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdNb2RlKE5iQ2FsZW5kYXJWaWV3TW9kZS5ZRUFSKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFZpZXdNb2RlKE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hhbmdlVmlzaWJsZU1vbnRoKGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgdGhpcy52aXNpYmxlRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTW9udGgodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hhbmdlVmlzaWJsZVllYXIoZGlyZWN0aW9uOiBudW1iZXIpIHtcbiAgICB0aGlzLnZpc2libGVEYXRlID0gdGhpcy5kYXRlU2VydmljZS5hZGRZZWFyKHRoaXMudmlzaWJsZURhdGUsIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGNoYW5nZVZpc2libGVZZWFycyhkaXJlY3Rpb246IG51bWJlcikge1xuICAgIHRoaXMudmlzaWJsZURhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZFllYXIodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uICogdGhpcy55ZWFyTW9kZWxTZXJ2aWNlLmdldFllYXJzSW5WaWV3KCkpO1xuICB9XG59XG4iLCI8bmItY2FyZD5cbiAgPG5iLWNhcmQtaGVhZGVyICpuZ0lmPVwic2hvd05hdmlnYXRpb25cIiBjbGFzcz1cImNhbGVuZGFyLW5hdmlnYXRpb25cIj5cbiAgICA8bmItY2FsZW5kYXItdmlldy1tb2RlIFtkYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2aWV3TW9kZV09XCJhY3RpdmVWaWV3TW9kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlTW9kZSk9XCJvbkNoYW5nZVZpZXdNb2RlKClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXZpZXctbW9kZT5cblxuICAgIDxuYi1jYWxlbmRhci1wYWdlYWJsZS1uYXZpZ2F0aW9uIChwcmV2KT1cIm5hdmlnYXRlUHJldigpXCIgKG5leHQpPVwibmF2aWdhdGVOZXh0KClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXBhZ2VhYmxlLW5hdmlnYXRpb24+XG4gIDwvbmItY2FyZC1oZWFkZXI+XG5cbiAgPG5iLWNhcmQtYm9keSBbbmdTd2l0Y2hdPVwiYWN0aXZlVmlld01vZGVcIj5cblxuICAgIDxuYi1jYWxlbmRhci1kYXktcGlja2VyICpuZ1N3aXRjaENhc2U9XCJWaWV3TW9kZS5EQVRFXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYm91bmRpbmdNb250aHNdPVwiYm91bmRpbmdNb250aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NlbGxDb21wb25lbnRdPVwiZGF5Q2VsbENvbXBvbmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Zpc2libGVEYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGF0ZV09XCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2hvd1dlZWtOdW1iZXJdPVwic2hvd1dlZWtOdW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaXJzdERheU9mV2Vla109XCJmaXJzdERheU9mV2Vla1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGVDaGFuZ2UpPVwiZGF0ZUNoYW5nZS5lbWl0KCRhbnkoJGV2ZW50KSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyU3ltYm9sXT1cIndlZWtOdW1iZXJTeW1ib2xcIj5cbiAgICA8L25iLWNhbGVuZGFyLWRheS1waWNrZXI+XG5cbiAgICA8bmItY2FsZW5kYXIteWVhci1waWNrZXIgKm5nU3dpdGNoQ2FzZT1cIlZpZXdNb2RlLllFQVJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VsbENvbXBvbmVudF09XCJ5ZWFyQ2VsbENvbXBvbmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRlXT1cIiRhbnkoZGF0ZSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3llYXJdPVwidmlzaWJsZURhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeWVhckNoYW5nZSk9XCJzZXRWaXNpYmxlRGF0ZSgkZXZlbnQpOyBzZXRWaWV3TW9kZShWaWV3TW9kZS5NT05USClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXllYXItcGlja2VyPlxuXG4gICAgPG5iLWNhbGVuZGFyLW1vbnRoLXBpY2tlciAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuTU9OVEhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NlbGxDb21wb25lbnRdPVwibW9udGhDZWxsQ29tcG9uZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21vbnRoXT1cInZpc2libGVEYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRlXT1cIiRhbnkoZGF0ZSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1vbnRoQ2hhbmdlKT1cInNldFZpc2libGVEYXRlKCRldmVudCk7IHNldFZpZXdNb2RlKFZpZXdNb2RlLkRBVEUpXCI+XG4gICAgPC9uYi1jYWxlbmRhci1tb250aC1waWNrZXI+XG5cbiAgPC9uYi1jYXJkLWJvZHk+XG5cbjwvbmItY2FyZD5cbiJdfQ==